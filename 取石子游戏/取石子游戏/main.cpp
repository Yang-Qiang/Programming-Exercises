class Stones {
public:
	vector<int> result(int A, int B, int n, vector<int> e, vector<int> a) {
		// write code here
		const long long inf = 0x3f3f3f3f3f3f3f3f;
		vector<vector<long long>>dp(n + 1, vector<long long>(200, inf));
		int sum = 0, ans;
		dp[n][0] = -inf;
		for (int i = n - 1; i >= 0; i--) {
			sum += a[i];
			for (int j = 0; j <= sum; j++) {
				long long Achoose = -(dp[i + 1][sum - j + 1] - 1) - e[i];
				long long Apass = max(1ll, dp[i + 1][j] + (e[i] + 1));
				dp[i][j] = min(Achoose, Apass);
				if (i == 0 && dp[i][j] <= A - B)
					ans = j;
			}
		}
		return vector<int>{ans, sum - ans};
	}
};


//首先根据题意可以得到两点观察：
//1. 一个玩家要跳过当前回合，那么他的能量必须比对手大。
//这是因为：
//(1) 若跳过当前回合相比于不跳过而言并不能得到更多的分数，那么他必然不会跳过；
//(2) 若能得到更多的分数，在他跳过之后，那么对手也同样会选择跳过，这样谁的能量少，谁最终会因耗尽能量而被迫选择不跳过。
//2. 一个玩家的最优策略是：在每一轮，从跳过和不跳过两种动作里，选择一种能够得到更多分数的动作。
//
//基于观察1，可以发现我们只需要考虑两位玩家的能量差值就行了，而不必考虑他们的能量分别是多少。即Alice有3点能量，Bob有2点能量，
//他们的能量差值是3 - 2 = 1，这和 Alice有2点能量，Bob有1点能量的情况是一样的。
//基于观察2，可以发现最优动作的选择是依赖于两个动作后续的总得分的，所以我们需要从后往前计算每一轮的后续最优总得分来倒推出每一轮的最优动作。
//其实就是动态规划的思想。
//
//一个比较容易想到的状态定义是：dp[i][j]表示第i轮时，先手玩家以j的能量差值在后续轮中所能获得的最多分数。但这样定义有一些问题：差值j可能是负数，
//且能量的取值范围是0~10 ^ 9，时空复杂度都太高。
//
//仔细观察题目设定后发现，所有分数的和是小于等于100的（然而样例里超过了100，但经验证可以保证小于200），这其实是 出题人 在暗示他的意图，
//他希望我们这样来定义状态：dp[i][j]表示第 i轮至第n轮先手玩家（先手指的是在第i轮先手）
//总共获得j分所需的最少能量差值。若我们能计算出所有的dp[i][j]，那么这局游戏Alice的最优得分就是满足dp[1][j] <= A - B的最大的j
//（下面代码中轮数是从0开始的，略有不一致）。
//
//现在的任务是给出dp[i][j]的递推关系式：
//(1) 若玩家跳过第i轮，那么有dp[i][j] = max(1, dp[i + 1][j] + e[i] + 1)。
//max里第一项表示玩家的能量必须比对手大(基于观察1)，第二项里 + e[i] + 1表示因玩家跳过造成对手增长的能量值。
//(2) 若玩家不跳过第i轮，那么有dp[i][j] = -(dp[i + 1][sum - j + 1] - 1) - e[i]，其中sum表示第i至第n轮的分数总和。
//dp[i + 1][sum - j + 1] - 1表示对手在第i + 1轮及之后获得sum - j分所需的最大能量差值（比较难想到！）， - e[i]表示玩家因选择第i轮的石头造成对手损失的能量值。
//而玩家的最优策略是，在(1)和(2)两种情况里选择需要较小能量差值的动作。
//至此，此题终于被完美解决。

//对手在i + 1轮及以后获得sum - j分所需的能量值是一个区间[a, b]，玩家在第i
//轮选择不跳过，则需要至少有 - b - e[i]的能量值保证对手的得分不超过sum - j。我们知道a = dp[i + 1][sum - j]，但
//不知道b是多少。但是我们知道对手在i + 1轮及以后获得sum - j + 1分所需的能量值也是一个区间[b + 1, c]，其
//中b + 1 = dp[i + 1][sum - j + 1]，这样我们就能求出b了。